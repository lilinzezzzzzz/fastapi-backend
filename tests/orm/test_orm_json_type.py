import os
import sys
import types
from datetime import datetime
from unittest.mock import MagicMock

import pytest
import pytest_asyncio
from sqlalchemy import String
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.orm import Mapped, mapped_column

# ==========================================
# 1. 增强版 Mock 策略
# ==========================================

current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(os.path.dirname(current_dir))  # 根据你的目录结构调整
pkg_path = os.path.join(project_root, "pkg")

# 1.1 Mock pkg.toolkit.json (避免依赖 orjson)
mock_json = types.ModuleType("pkg.toolkit.json")
mock_json.orjson_dumps = lambda x, **kwargs: '{"mock": "json"}'
mock_json.orjson_loads = lambda x: {"mock": "json"}
mock_json.JsonInputType = str | bytes
sys.modules["pkg.toolkit.json"] = mock_json

# 1.2 Mock pkg.toolkit.timer
mock_timer = types.ModuleType("pkg.toolkit.timer")
mock_timer.utc_now_naive = lambda: datetime.utcnow()
sys.modules["pkg.toolkit.timer"] = mock_timer

# 1.3 Mock pkg.toolkit.context (修复 LookupError 的关键)
mock_ctx_module = types.ModuleType("pkg.toolkit.context")
mock_ctx_func = MagicMock()
mock_ctx_func.return_value = 999  # Mock user_id = 999
mock_ctx_module.get_user_id = mock_ctx_func
sys.modules["pkg.toolkit.context"] = mock_ctx_module
# 同时 Mock pkg.context 以防万一
sys.modules["pkg.context"] = mock_ctx_module

# 1.4 Mock 其他工具
mock_logger = MagicMock()
mock_snowflake = MagicMock()
_id_counter = 0


def mock_gen_id():
    global _id_counter
    _id_counter += 1
    return _id_counter


mock_snowflake.generate_snowflake_id = mock_gen_id
sys.modules["pkg.logger_tool"] = mock_logger
sys.modules["pkg.toolkit.inter.snowflake_id_generator"] = mock_snowflake

# ==========================================
# 2. 导入目标代码
# ==========================================
# 确保项目根目录在 sys.path 中
if project_root not in sys.path:
    sys.path.insert(0, project_root)

try:
    # 尝试导入，这里会自动使用上面的 Mocks
    from pkg.database.base import Base, JSONType, ModelMixin, new_async_session_maker
    from pkg.database.dao import BaseDao  # 假设 BaseDao 在 dao.py
except ImportError as e:
    # 如果你的目录结构不同，这里做个兼容处理，假设直接从 pkg.database 导
    try:
        from pkg.database import Base, BaseDao, JSONType, ModelMixin, new_async_session_maker
    except ImportError:
        print(f"CRITICAL: Cannot import from pkg.database. path={sys.path}")
        raise e


# ==========================================
# 3. 定义测试模型
# ==========================================
class User(ModelMixin):
    __tablename__ = "users"
    username: Mapped[str] = mapped_column(String(50))
    email: Mapped[str] = mapped_column(String(100), nullable=True)

    # [新增] 验证 JSONType 和 Mutable 追踪
    info: Mapped[dict] = mapped_column(JSONType, default=dict)


class UserDao(BaseDao[User]):
    pass


# ==========================================
# 4. Pytest Fixtures
# ==========================================


@pytest_asyncio.fixture(loop_scope="function")
async def db_session():
    # 使用内存 SQLite
    engine = create_async_engine("sqlite+aiosqlite:///:memory:", echo=False)

    # 建表
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    session_maker = new_async_session_maker(engine)

    yield session_maker

    await engine.dispose()


@pytest.fixture
def user_dao(db_session):
    return UserDao(session_provider=db_session, model_cls=User)


# ==========================================
# 5. 测试用例
# ==========================================


@pytest.mark.asyncio
async def test_create_and_save_strictness(user_dao, db_session):
    """测试创建对象、严格Save检查和ID生成"""
    # 1. Create (Transient)
    user = User.create(username="alice", info={"role": "admin"})
    assert user.id is not None, "ID should be generated by create()"
    assert user.creator_id == 999
    assert user.info == {"role": "admin"}

    # 2. Save (Insert)
    await user.save(db_session)

    # 验证数据库
    db_user = await user_dao.query_by_primary_id(user.id)
    assert db_user is not None
    assert db_user.username == "alice"
    assert db_user.info == {"role": "admin"}

    # 3. Strict Save 检查 (持久化对象不能调 save)
    with pytest.raises(RuntimeError) as exc:
        await db_user.save(db_session)
    assert "strictly for INSERT" in str(exc.value)


@pytest.mark.asyncio
async def test_update_strictness(user_dao, db_session):
    """测试更新逻辑、Mutable JSON 追踪和严格Update检查"""
    # 初始化数据
    user = User.create(username="bob", info={"login_count": 0})
    await user.save(db_session)

    # 1. Update Persistent Object (常规字段 + JSON Mutation)
    async with db_session() as session:
        # 在同一个 session 事务中获取并更新，模拟真实场景
        async with session.begin():
            db_user = await session.get(User, user.id)

            # [关键测试] 修改 JSON 内部字段，验证 MutableDict 是否生效
            # 如果 JSONType 没有定义 python_type=dict，这里会报错或不生效
            db_user.info["login_count"] = 1
            db_user.info["last_login"] = "today"

            # 使用 Dao 或 Mixin 的 update 方法更新常规字段
            # 注意：update() 方法内部会 commit，但我们这里在 session 上下文中手动处理更可控
            # 这里演示使用 mixin 的 update 方法
            await db_user.update(lambda: session, username="bob_updated")

    # 2. 验证变更
    reloaded = await user_dao.query_by_primary_id(user.id)
    assert reloaded.username == "bob_updated"
    assert reloaded.updater_id == 999
    # 验证 JSON 变更被持久化了
    assert reloaded.info["login_count"] == 1
    assert "last_login" in reloaded.info

    # 3. Strict Update 检查 (新对象不能调 update)
    new_user = User.create(username="charlie")
    with pytest.raises(RuntimeError) as exc:
        await new_user.update(db_session, username="fail")
    assert "strictly for UPDATE" in str(exc.value)


@pytest.mark.asyncio
async def test_batch_insert_instances(user_dao, db_session):
    """测试批量对象插入"""
    users = [User.create(username=f"user_{i}") for i in range(5)]

    await User.insert_instances(items=users, session_provider=db_session)

    count = await user_dao.counter.count()
    assert count == 5

    ids = [u.id for u in users]
    fetched = await user_dao.query_by_ids(ids)
    assert len(fetched) == 5


@pytest.mark.asyncio
async def test_batch_insert_rows(user_dao, db_session):
    """测试批量字典插入"""
    rows = [{"username": "dict_1"}, {"username": "dict_2"}]

    await User.insert_rows(rows=rows, session_provider=db_session)

    count = await user_dao.counter.count()
    assert count == 2


@pytest.mark.asyncio
async def test_query_builder(user_dao, db_session):
    """测试查询构建器"""
    # 准备数据
    await User.insert_rows(rows=[{"username": f"u{i}"} for i in range(1, 6)], session_provider=db_session)

    # Test IN with values
    res = await user_dao.querier.in_(User.username, ["u1", "u2"]).all()
    assert len(res) == 2

    # Test IN with empty list (Expect ValueError)
    # 确保你的 Dao 代码中有处理空列表抛出 ValueError 的逻辑，否则这里会断言失败
    # 如果 Dao 层没有抛错而是忽略，请移除 pytest.raises
    with pytest.raises(ValueError) as exc:
        await user_dao.querier.in_(User.username, []).all()
    assert "empty" in str(exc.value) or "Empty" in str(exc.value)

    # Test Pagination
    page_res = await user_dao.querier_unsorted.asc_(User.id).paginate(page=1, limit=2).all()
    assert len(page_res) == 2
    assert page_res[0].username == "u1"


@pytest.mark.asyncio
async def test_soft_delete(user_dao, db_session):
    """测试软删除"""
    user = User.create(username="del_me")
    await user.save(db_session)

    await user_dao.ins_updater(user).soft_delete()

    # 默认不查出
    assert await user_dao.querier.eq_(User.id, user.id).first() is None
    # inc_deleted 查出
    assert await user_dao.querier_inc_deleted.eq_(User.id, user.id).first() is not None


@pytest.mark.asyncio
async def test_updater_builder_logic(user_dao, db_session):
    """测试 UpdateBuilder"""
    user = User.create(username="old_name")
    await user.save(db_session)

    await user_dao.ins_updater(user).update(username="new_name")

    reloaded = await user_dao.query_by_primary_id(user.id)
    assert reloaded.username == "new_name"


if __name__ == "__main__":
    # 方便直接 debug
    sys.exit(pytest.main(["-s", "-v", __file__]))
