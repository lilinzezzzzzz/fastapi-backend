import sys
import pytest
import pytest_asyncio  # <--- 新增导入
import os
import types
from unittest.mock import MagicMock
from datetime import datetime
from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy.ext.asyncio import create_async_engine

# ==========================================
# 1. 混合 Mock 策略 (保持不变，这部分是正确的)
# ==========================================

current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
pkg_path = os.path.join(project_root, "pkg")

mock_pkg = types.ModuleType("pkg")
mock_pkg.__path__ = [pkg_path]

mock_pkg.orjson_dumps = lambda x: "json"
mock_pkg.orjson_loads = lambda x: {}
mock_pkg.orjson_loads_types = (str, bytes)
mock_pkg.get_utc_without_tzinfo = lambda: datetime.utcnow()
mock_pkg.unique_list = lambda x, exclude_none=False: list(set([i for i in x if i is not None] if exclude_none else x))

mock_context = MagicMock()
mock_context.ctx.get_user_id.return_value = 999

mock_logger = MagicMock()
mock_snowflake = MagicMock()

_id_counter = 0


def mock_gen_id():
    global _id_counter
    _id_counter += 1
    return _id_counter


mock_snowflake.generate_snowflake_id = mock_gen_id

sys.modules["pkg"] = mock_pkg
sys.modules["pkg.context"] = mock_context
sys.modules["pkg.logger_tool"] = mock_logger
sys.modules["pkg.snowflake_tool"] = mock_snowflake

# ==========================================
# 2. 导入目标代码
# ==========================================
try:
    from pkg.database import ModelMixin, BaseDao, Base, new_async_session_maker
except ImportError as e:
    print(f"Import Error: {e}")
    print(f"Looking for pkg at: {pkg_path}")
    raise e


# ==========================================
# 3. 定义测试模型
# ==========================================
class User(ModelMixin):
    __tablename__ = "users"
    username: Mapped[str] = mapped_column(String(50))
    email: Mapped[str] = mapped_column(String(100), nullable=True)


class UserDao(BaseDao[User]):
    pass


# ==========================================
# 4. Pytest Fixtures (关键修改区域)
# ==========================================

# 修改点：使用 @pytest_asyncio.fixture 替代 @pytest.fixture
# 并且显式指定 loop_scope="function" 以符合新版规范
@pytest_asyncio.fixture(loop_scope="function")
async def db_session():
    # 使用内存 SQLite
    engine = create_async_engine("sqlite+aiosqlite:///:memory:", echo=False)

    # 建表
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    session_maker = new_async_session_maker(engine)

    yield session_maker

    await engine.dispose()


@pytest.fixture
def user_dao(db_session):
    # 这里 db_session 是异步 fixture，user_dao 是同步 fixture
    # pytest-asyncio 能够处理这种依赖，只要 db_session 定义正确
    return UserDao(session_provider=db_session, model_cls=User)


# ==========================================
# 5. 测试用例
# ==========================================

@pytest.mark.asyncio
async def test_create_and_save_strictness(user_dao, db_session):
    """测试创建对象、严格Save检查和ID生成"""
    # 1. Create (Transient)
    user = User.create(username="alice")
    assert user.id is not None, "ID should be generated by create()"
    assert user.creator_id == 999

    # 2. Save (Insert)
    await user.save(db_session)

    # 验证数据库
    db_user = await user_dao.query_by_primary_id(user.id)
    assert db_user is not None
    assert db_user.username == "alice"

    # 3. Strict Save 检查 (持久化对象不能调 save)
    with pytest.raises(RuntimeError) as exc:
        await db_user.save(db_session)
    assert "strictly for INSERT" in str(exc.value)


@pytest.mark.asyncio
async def test_update_strictness(user_dao, db_session):
    """测试更新逻辑和严格Update检查"""
    user = User.create(username="bob")
    await user.save(db_session)

    # 1. Update Persistent Object
    db_user = await user_dao.query_by_primary_id(user.id)
    await db_user.update(db_session, username="bob_updated")

    reloaded = await user_dao.query_by_primary_id(user.id)
    assert reloaded.username == "bob_updated"
    assert reloaded.updater_id == 999

    # 2. Strict Update 检查 (新对象不能调 update)
    new_user = User.create(username="charlie")
    with pytest.raises(RuntimeError) as exc:
        await new_user.update(db_session, username="fail")
    assert "strictly for UPDATE" in str(exc.value)


@pytest.mark.asyncio
async def test_batch_insert_instances(user_dao, db_session):
    """测试批量对象插入"""
    users = [User.create(username=f"user_{i}") for i in range(5)]

    await User.insert_instances(items=users, session_provider=db_session)

    count = await user_dao.counter.count()
    assert count == 5

    ids = [u.id for u in users]
    fetched = await user_dao.query_by_ids(ids)
    assert len(fetched) == 5


@pytest.mark.asyncio
async def test_batch_insert_rows(user_dao, db_session):
    """测试批量字典插入"""
    rows = [{"username": "dict_1"}, {"username": "dict_2"}]

    await User.insert_rows(rows=rows, session_provider=db_session)

    count = await user_dao.counter.count()
    assert count == 2


@pytest.mark.asyncio
async def test_query_builder(user_dao, db_session):
    """测试查询构建器"""
    # 准备数据
    await User.insert_rows(
        rows=[{"username": f"u{i}"} for i in range(1, 6)],
        session_provider=db_session
    )

    # Test IN with values
    res = await user_dao.querier.in_(User.username, ["u1", "u2"]).all()
    assert len(res) == 2

    # ------------------------------------------------------------
    # 修改点：Test IN with empty list (Expect ValueError)
    # ------------------------------------------------------------
    with pytest.raises(ValueError) as exc:
        await user_dao.querier.in_(User.username, []).all()
    assert "cannot be empty" in str(exc.value)

    # Test Pagination
    page_res = await user_dao.querier_unsorted.asc_(User.id).paginate(page=1, limit=2).all()
    assert len(page_res) == 2
    assert page_res[0].username == "u1"


@pytest.mark.asyncio
async def test_soft_delete(user_dao, db_session):
    """测试软删除"""
    user = User.create(username="del_me")
    await user.save(db_session)

    await user_dao.ins_updater(user).soft_delete().execute()

    # 默认不查出
    assert await user_dao.querier.eq_(User.id, user.id).first() is None
    # inc_deleted 查出
    assert await user_dao.querier_inc_deleted.eq_(User.id, user.id).first() is not None


@pytest.mark.asyncio
async def test_updater_builder_logic(user_dao, db_session):
    """测试 UpdateBuilder"""
    user = User.create(username="old_name")
    await user.save(db_session)

    await user_dao.ins_updater(user).update(username="new_name").execute()

    reloaded = await user_dao.query_by_primary_id(user.id)
    assert reloaded.username == "new_name"
